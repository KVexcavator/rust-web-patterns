// Проверка состояния структуры с помощью компилятора
// Пример — транзакция в базе данных, как только мы зафиксировали транзакцию, мы не можем отменить ее или добавить другую операцию к транзакции

// PhantomData — это заполнитель, который фактически не содержит никаких данных, но компилятор может учитывать эти фиктивные данные при компиляции

use std::marker::PhantomData;

struct InProgress;
struct Committed;
struct RolledBack;

struct Transaction<State> {
    id: u32,
    state: PhantomData<State>,
}

impl Transaction<InProgress> {
  fn new(id: u32) -> Self {
      Transaction {
          id,
          state: PhantomData,
      }
  }
  fn commit(self) -> Transaction<Committed> {
      println!("Transaction {} committed.", self.id);
      Transaction {
          id: self.id,
          state: PhantomData,
      }
  }
  fn rollback(self) -> Transaction<RolledBack> {
      println!("Transaction {} rolled back.", self.id);
      Transaction {
          id: self.id,
          state: PhantomData,
      }
  }
}

// какая то функция не важно
fn process_in_progress_transaction(tx: &Transaction<InProgress>) {
    println!(
        "Processing transaction {} which is in progress.",
        tx.id
    );
}

fn main() {
    let tx = Transaction::<InProgress>::new(1);
    // изменили состояние транзакции
    let tx = tx.commit();
    process_in_progress_transaction(&tx);
}

// если это запустить, компилятор выдаст ошибку
// process_in_progress_transaction(&tx);
// ------------------------------- ^^^
// expected `&Transaction<InProgress>`,
// found `&Transaction<Committed>`

// Это прямое указание на проблему. Нам сообщают, что
// мы уже зафиксировали транзакцию до попытки передать её в функцию. 
// Шаблон состояния типа позволяет нам заставить компилятор проверять, находится ли структура в определённом состоянии, обеспечивая очень быструю
// обратную связь о потенциальных ошибках. Исползуется для:
// - Пользовательские сессии: Когда пользователь выходит из системы, его состояние изменяется. Или состояние может быть ролью пользователя, так что только определённые части кодовой базы доступны структурам пользователей, имеющим определённую роль.
// - Распределение ресурсов: Здесь мы могли бы обеспечить эффективное использование ресурсов. Мы могли бы иметь состояния, такие как Доступно, Используется или Освобождён
// - Управление кэшем: состояния, такие как Пусто, Выборка или Доступно, могут определять, какие области кода доступны для структуры, обрабатывающей кэш, или для доступа к кэшу
// - Многоэтапные процессы: состояния, такие как Шаг 1, Шаг 2, Шаг 3 и так далее, могут принудительно запускать структуру, гарантируя, что она никогда не сможет вернуться на шаг назад или пропустить шаг